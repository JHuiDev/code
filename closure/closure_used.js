function count() {
    var i = 0;
    return function() {
        return i++;
    }
}
//一般的函数运行完之后，占用的内存就会被释放掉。
// 闭包的缓存机制是因为我们的函数调用之后返回的新函数被保存再了变量中,而变量的内存是不会像函数一样使用完就就会释放的
// 而我们的闭包需要依赖外层的函数的作用域，这样一来外层函数中的变量也就不会释放。
//count()是一个累加器，我们使用num变量来保存该函数返回的闭包。也就是说此时的变量就是我们返回的匿名函数
var num = count();
//通过num(),返回累加的值，由于num依附着count函数内的变量，该变量就会被保存。
console.log(num());
console.log(num());
//如果我们使用的是直接双括号调用count()函数，由于count函数事先没有被变量引用保存。
// 当函数执行完毕后，就会和普通函数一样释放内存，i的累加值也就相应不会保存。
// 这也就说明了闭包的缓存机制是因为被引用了才得以实现
console.log(count()());
console.log(count()());
console.log(count()());